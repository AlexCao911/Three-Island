/**
 * IMPORTANT: Loading glTF models into a Three.js scene is a lot of work.
 * Before we can configure or animate our model's meshes, we need to iterate through
 * each part of our model's meshes and save them separately.
 *
 * But luckily there is an app that turns gltf or glb files into jsx components
 * For this model, visit https://gltf.pmnd.rs/
 * And get the code. And then add the rest of the things.
 * YOU DON'T HAVE TO WRITE EVERYTHING FROM SCRATCH
 */

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 island.glb -T --types
Author: nimzu (https://sketchfab.com/nimzuk)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/foxs-islands-163b68e09fcc47618450150be7785907
Title: Fox's islands
*/
import { useGLTF } from '@react-three/drei'
import { useRef, useEffect, useCallback } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { a } from '@react-spring/three'
import * as THREE from 'three'

interface IslandProps {
  position?: [number, number, number]
  rotation?: [number, number, number]
  scale?: [number, number, number]
  isRotating?: boolean
  setIsRotating?: (rotating: boolean) => void
  setCurrentStage?: (stage: number | null) => void
}

// Island 3D model from: https://sketchfab.com/3d-models/foxs-islands-163b68e09fcc47618450150be7785907
export function Island({
  isRotating,
  setIsRotating,
  setCurrentStage,

  ...props
}: IslandProps) {
  // Create a reference to the island group for direct manipulation
  const islandRef = useRef<THREE.Group>(null);

  // Get access to the Three.js renderer and viewport
  const { gl, viewport } = useThree();

  // Load the 3D model from the provided GLTF file
  const { nodes, materials } = useGLTF('/assets/3d/transformed/island-transformed.glb')

  // Enhanced interaction state management
  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;
  
  // Advanced interaction features
  const isDragging = useRef(false);
  const rotationMomentum = useRef(0);
  const targetRotation = useRef(0);
  const lastInteractionTime = useRef(Date.now());
  
  // Enhanced sensitivity and smoothing
  const mouseSensitivity = 0.008; // Reduced for smoother control
  const keyboardSensitivity = 0.003;
  const momentumDecay = 0.92; // Smoother momentum decay

  // Enhanced pointer down with better interaction feedback
  const handlePointerDown = useCallback((event: PointerEvent) => {
    event.stopPropagation();
    event.preventDefault();
    
    isDragging.current = true;
    lastInteractionTime.current = Date.now();
    
    if (setIsRotating) setIsRotating(true);

    const clientX = event.clientX;
    lastX.current = clientX;
    
    // Reset momentum when user starts interacting
    rotationMomentum.current = 0;
    
    // Add subtle haptic feedback for mobile devices
    if ('vibrate' in navigator) {
      navigator.vibrate(10);
    }
  }, [setIsRotating]);

  // Enhanced pointer up with momentum preservation
  const handlePointerUp = useCallback((event: PointerEvent) => {
    event.stopPropagation();
    event.preventDefault();
    
    isDragging.current = false;
    
    // Preserve momentum for natural feel
    rotationMomentum.current = rotationSpeed.current * 0.8;
    
    if (setIsRotating) setIsRotating(false);
  }, [setIsRotating]);

  // Enhanced pointer move with improved sensitivity and smoothing
  const handlePointerMove = useCallback((event: PointerEvent) => {
    event.stopPropagation();
    event.preventDefault();

    if (isDragging.current && islandRef.current) {
      lastInteractionTime.current = Date.now();
      
      const clientX = event.clientX;
      const rawDelta = (clientX - lastX.current) / viewport.width;
      
      // Apply enhanced sensitivity with easing
      const delta = rawDelta * mouseSensitivity * Math.PI;
      
      // Smooth rotation with interpolation
      const smoothedDelta = delta * 0.7 + rotationSpeed.current * 0.3;
      
      if (islandRef.current) {
        islandRef.current.rotation.y += smoothedDelta;
        targetRotation.current = islandRef.current.rotation.y;
      }

      lastX.current = clientX;
      rotationSpeed.current = smoothedDelta;
    }
  }, [viewport.width]);

  // Enhanced keyboard controls with smooth acceleration
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    lastInteractionTime.current = Date.now();
    
    if (event.key === "ArrowLeft" || event.key === "a" || event.key === "A") {
      event.preventDefault();
      if (!isRotating && setIsRotating) setIsRotating(true);
      
      const rotationDelta = keyboardSensitivity * Math.PI;
      rotationSpeed.current = Math.min(rotationSpeed.current + rotationDelta, 0.02);
      
      if (islandRef.current) {
        targetRotation.current += rotationDelta;
      }
    } else if (event.key === "ArrowRight" || event.key === "d" || event.key === "D") {
      event.preventDefault();
      if (!isRotating && setIsRotating) setIsRotating(true);
      
      const rotationDelta = -keyboardSensitivity * Math.PI;
      rotationSpeed.current = Math.max(rotationSpeed.current + rotationDelta, -0.02);
      
      if (islandRef.current) {
        targetRotation.current += rotationDelta;
      }
    }
  }, [isRotating, setIsRotating]);

  // Enhanced keyup with momentum preservation
  const handleKeyUp = useCallback((event: KeyboardEvent) => {
    if (event.key === "ArrowLeft" || event.key === "ArrowRight" || 
        event.key === "a" || event.key === "A" || 
        event.key === "d" || event.key === "D") {
      
      // Preserve some momentum for natural feel
      rotationMomentum.current = rotationSpeed.current * 0.5;
      
      if (setIsRotating) setIsRotating(false);
    }
  }, [setIsRotating]);

  // Touch events for mobile devices
  const handleTouchStart = useCallback((event: TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();
    if (setIsRotating) setIsRotating(true);

    const clientX = event.touches ? event.touches[0].clientX : 0;
    lastX.current = clientX;
  }, [setIsRotating]);

  const handleTouchEnd = useCallback((event: TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();
    if (setIsRotating) setIsRotating(false);
  }, [setIsRotating]);

  const handleTouchMove = useCallback((event: TouchEvent) => {
    event.stopPropagation();
    event.preventDefault();

    if (isRotating && islandRef.current) {
      const clientX = event.touches ? event.touches[0].clientX : 0;
      const delta = (clientX - lastX.current) / viewport.width;

      islandRef.current.rotation.y += delta * 0.01 * Math.PI;
      lastX.current = clientX;
      rotationSpeed.current = delta * 0.01 * Math.PI;
    }
  }, [isRotating, viewport.width]);

  useEffect(() => {
    // Add event listeners for pointer and keyboard events
    const canvas = gl.domElement;
    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    canvas.addEventListener('touchstart', handleTouchStart);
    canvas.addEventListener('touchend', handleTouchEnd);
    canvas.addEventListener('touchmove', handleTouchMove);

    // Remove event listeners when component unmounts
    return () => {
      canvas.removeEventListener('pointerdown', handlePointerDown);
      canvas.removeEventListener('pointerup', handlePointerUp);
      canvas.removeEventListener('pointermove', handlePointerMove);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      canvas.removeEventListener('touchstart', handleTouchStart);
      canvas.removeEventListener('touchend', handleTouchEnd);
      canvas.removeEventListener('touchmove', handleTouchMove);
    };
  }, [gl, handlePointerDown, handlePointerUp, handlePointerMove, handleKeyDown, handleKeyUp, handleTouchStart, handleTouchEnd, handleTouchMove]);

  // Enhanced frame update with smooth interactions (auto-rotation disabled)
  useFrame((state, delta) => {
    if (!islandRef.current) return;

    const currentTime = Date.now();
    const timeSinceLastInteraction = currentTime - lastInteractionTime.current;
    
    // Enhanced rotation logic without auto-rotation
    if (!isDragging.current && !isRotating) {
      // Apply momentum decay
      rotationMomentum.current *= momentumDecay;
      rotationSpeed.current *= dampingFactor;

      // Apply momentum rotation only (no auto-rotation)
      const totalRotation = rotationSpeed.current + rotationMomentum.current;
      
      if (Math.abs(totalRotation) > 0.0001) {
        islandRef.current.rotation.y += totalRotation;
        targetRotation.current = islandRef.current.rotation.y;
      }

      // Stop micro-movements
      if (Math.abs(rotationSpeed.current) < 0.0001 && Math.abs(rotationMomentum.current) < 0.0001) {
        rotationSpeed.current = 0;
        rotationMomentum.current = 0;
      }
    } else {
      // Smooth interpolation to target rotation during active interaction
      const rotationDiff = targetRotation.current - islandRef.current.rotation.y;
      if (Math.abs(rotationDiff) > 0.001) {
        islandRef.current.rotation.y += rotationDiff * 0.1;
      }
    }

    // Enhanced stage detection with smoother transitions
    const rotation = islandRef.current.rotation.y;
    const normalizedRotation = ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

    // More precise stage detection
    if (setCurrentStage) {
      let newStage: number | null = null;
      
      // Expanded stage ranges for smoother transitions
      if (normalizedRotation >= 5.3 && normalizedRotation <= 6.0) {
        newStage = 4;
      } else if (normalizedRotation >= 0.7 && normalizedRotation <= 1.5) {
        newStage = 3;
      } else if (normalizedRotation >= 2.2 && normalizedRotation <= 2.8) {
        newStage = 2;
      } else if (normalizedRotation >= 4.0 && normalizedRotation <= 4.9) {
        newStage = 1;
      }
      
      setCurrentStage(newStage);
    }

    // Subtle floating animation when idle
    if (timeSinceLastInteraction > 1000) {
      const floatOffset = Math.sin(state.clock.elapsedTime * 0.5) * 0.02;
      islandRef.current.position.y += floatOffset * delta;
    }
  });

  return (
    // Island 3D model with enhanced interactions inspired by JOSHUA's World
    <a.group ref={islandRef} {...props}>
      {/* Tree meshes with enhanced materials for better visual feedback */}
      <mesh
        geometry={(nodes.polySurface944_tree_body_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      <mesh
        geometry={(nodes.polySurface945_tree1_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      <mesh
        geometry={(nodes.polySurface946_tree2_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      <mesh
        geometry={(nodes.polySurface947_tree1_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      <mesh
        geometry={(nodes.polySurface948_tree_body_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      <mesh
        geometry={(nodes.polySurface949_tree_body_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      {/* Main island rock base with enhanced shadows */}
      <mesh
        geometry={(nodes.pCube11_rocks1_0 as THREE.Mesh).geometry}
        material={materials.PaletteMaterial001}
        castShadow
        receiveShadow
      />
      
      {/* Subtle ambient particles for premium feel (optional) */}
      {/* You can add particle effects here similar to JOSHUA's World */}
    </a.group>
  )
}

// Preload the island model to improve performance
useGLTF.preload('/assets/3d/transformed/island-transformed.glb')

export default Island